#: vim: set fileencoding=utf-8 foldmethod=marker foldlevel=0:
#: vim: set colorcolumn=81 nospell:

#: `~/.bashrc`: executed by `bash(1)` for non-login shells.
#: This `.bashrc` modified some command from the default `.bashrc` of Ubuntu
#: Get the default `.bashrc`: https://gist.github.com/marioBonales/1637696
#: This one in scripted to use in modern Bash, terminal, not tend to portability

#: If not running interactively, don't do anything
[[ $- != *i* ]] && return

#: Create cache directory
export BASH_CACHE_DIR=~/.cache/bash
mkdir -p "$BASH_CACHE_DIR"

#: Make `less` more friendly for non-text input files, see `lesspipe(1)`
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

#: User aliases {{{

#: Force 80-column width to man page if the terminal is wider than 80 columns
alias man='MANWIDTH=$((COLUMNS > 80 ? 80 : COLUMNS)) man'

#: Own VSCode directory to use some extensions like Custom CSS and JS Loader
alias chown-code='sudo chown -R $(whoami) /usr/share/code/'

#: Force Google Chrome to use dark theme, only run after update
alias force-dark-chrome="sudo sed -i \
'/^Exec=/ s/$/ --enable-features=WebUIDarkMode --force-dark-mode/' \
/usr/share/applications/google-chrome.desktop"

#: Bash session without history logging
#: Set Oh My Posh theme
export POSHTHEME=~/.config/oh-my-posh/multiplex.omp.toml
# POSHTHEME=~/.poshthemes/test.omp.json
alias bashout="bash --init-file \
<(echo 'source ~/.bashrc; \
unset HISTFILE; \
PROMPT_COMMAND=; \
export NO_HISTORY=1; \
eval \"\$(oh-my-posh --init --shell bash --config $POSHTHEME)\"')"

#: A lite Bash version
alias bashlite='bash --rcfile ~/.vscode/.bashrc'

#: Kitty update
alias update-kitty="curl -L https://sw.kovidgoyal.net/kitty/installer.sh | \
sh /dev/stdin"

#: Update Oh My Posh
update-oh-my-posh() {
    [ "$1" == "" ] && tag='latest/download' || tag="download/v$1"
    url="https://github.com/JanDeDobbeleer/oh-my-posh/releases/$tag/posh-linux-amd64"
    sudo wget $url -O /usr/local/bin/oh-my-posh
    sudo chmod +x /usr/local/bin/oh-my-posh
}

#: Update Pyenv
alias update-pyenv='pyenv update'

#: Enable color support of `ls` and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors &&
        eval "$(dircolors -b ~/.dircolors)" ||
        eval "$(dircolors -b)"
    alias ls='ls --color=auto --hyperlink=auto'
    alias dir='dir --color=auto'
    alias vdir='vdir --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

#: Some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias lt='du -sh * | sort -h'
alias lsdir='ls -ld */'
alias lsfile='ls -flp | grep -v /'

#: Shutdown the computer
alias reboot='sudo shutdown -r now'
alias shutdown='sudo shutdown -h now'

#: Add an "alert" alias for long running commands, use like so:
#:     sleep 10; alert
alias alert="notify-send \
--urgency=low \
-i \"\$([ \$? = 0 ] && echo terminal || echo error)\" \
\"\$(history|tail -n1|sed -e 's/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//')\""

#: Clean all buffers
alias clean="clear && printf '\e[3J'"

#: Other aliases
alias python=python3
alias pip=pip3
alias icat='kitty +kitten icat'
alias pwsh='pwsh -NoLogo'
alias mnt="mount | \
awk -F' ' '{ printf \"%s\t%s\n\",\$1,\$3; }' | column -t | egrep ^/dev/ | sort"

alias open=xdg-open
command -v kitty &>/dev/null && {
    #: Wait for this implemented: https://github.com/BurntSushi/ripgrep/issues/665
    alias hg='kitty +kitten hyperlinked_grep'
    alias diff-kitty='kitty +kitten diff'
    alias ssh-kitty='kitty +kitten ssh'
}

alias printvar='(set -o posix; set)'

export VISUAL=vim

#: }}}

#: Functions {{{

#: Add function to existing trapped signals
#: https://stackoverflow.com/a/7287873
#: - 1st arg:  code to add
#: - remaining args:  names of traps to modify
add-trap() {
    trap_add_cmd=$1
    shift || fatal "${FUNCNAME} usage error"
    for trap_add_name in "$@"; do
        trap -- "$(
            extract_trap_cmd() { printf '%s\n' "$3"; }
            eval "extract_trap_cmd $(trap -p "${trap_add_name}")"
            printf '%s\n' "${trap_add_cmd}"
        )" "${trap_add_name}" ||
            fatal "unable to add to trap ${trap_add_name}"
    done
}
declare -f -t trap_add

#: Trim leading/trailing spaces and remove duplicate lines from `.bash_history`
#: https://unix.stackexchange.com/q/18212#comment1110864_18443
dedup-history() {
    tac <~/.cache/bash/history |
        #: Trim leading whitespaces
        awk '{ sub(/^[ \t]+/, ""); print }' |
        #: Trim trailing whitespaces
        awk '{ sub(/[ \t]+$/, ""); print }' |
        #: Remove duplicate lines
        awk '!a[$0]++' |
        tac >/tmp/deduped && mv -f /tmp/deduped ~/.cache/bash/history
}

#: Remove duplicate lines from `.bash_history`
#: https://unix.stackexchange.com/q/18212#comment865944_18443
dedup-history-2() {
    cat ~/.cache/bash/history |
        nl |
        sort -k 2 |
        tac |
        uniq -f 1 |
        sort -n |
        cut -f 2 |
        tee ~/.cache/bash/history
}

#: Remove last N lines from `.bash_history`, default is 1
remove-history() {
    sed -n -e :a -e "1,${1:-1}!{P;N;D;};N;ba" -i ~/.cache/bash/history
}

#: Get directory size
dsize() {
    [ "$1" != "" ] && dir=$1 || dir=$(pwd)
    echo $(du -hs $dir)
}

#: Extract compressed files
extract() {
    if [ -f $1 ]; then
        case $1 in
        *.tar.bz2) tar xjf $1 ;;
        *.tar.gz) tar xzf $1 ;;
        *.bz2) bunzip2 $1 ;;
        *.rar) rar x $1 ;;
        *.gz) gunzip $1 ;;
        *.tar) tar xf $1 ;;
        *.tbz2) tar xjf $1 ;;
        *.tgz) tar xzf $1 ;;
        *.zip) unzip $1 ;;
        *.Z) uncompress $1 ;;
        *.7z) 7z x $1 ;;
        *) echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

#: Grep process
psgrep() {
    if [ ! -z $1 ]; then
        echo "Grepping for processes matching $1..."
        ps aux | grep $1 | grep -v grep
    else
        echo "!! Need name to grep for"
    fi
}

#: Check if exist and source a file without repeat filepath
include() {
    [[ -f "$1" ]] && source "$1"
}

#: Source all other function files in my directory
[[ -d ~/.local/functions ]] && for file in ~/.local/functions/*; do source $file; done

#: }}}

#: System wide settings {{{

#: Define a few Colours
BLACK='\e[0;30m'
RED='\e[0;31m'
GREEN='\e[0;32m'
YELLOW='\e[0;33m'
BLUE='\e[0;34m'
PURPLE='\e[0;35m'
CYAN='\e[0;36m'
WHITE='\e[0;37m'
BRIGHT_BLACK='\e[0;90m'
BRIGHT_RED='\e[0;91m'
BRIGHT_GREEN='\e[0;92m'
BRIGHT_YELLOW='\e[0;93m'
BRIGHT_BLUE='\e[0;94m'
BRIGHT_PURPLE='\e[0;95m'
BRIGHT_CYAN='\e[0;96m'
BRIGHT_WHITE='\e[97m'
RESET='\e[0m'

#: Color the man page
#: Reference: https://unix.stackexchange.com/questions/119/colors-in-man-pages
export LESS_TERMCAP_mb=$(
    tput bold
    tput setaf 2
)
export LESS_TERMCAP_md=$(
    tput bold
    tput setaf 6
)
export LESS_TERMCAP_me=$(tput sgr0)
export LESS_TERMCAP_so=$(
    tput bold
    tput setaf 3
    tput setab 4
)
export LESS_TERMCAP_se=$(
    tput rmso
    tput sgr0
)
export LESS_TERMCAP_us=$(
    tput smul
    tput bold
    tput setaf 7
)
export LESS_TERMCAP_ue=$(
    tput rmul
    tput sgr0
)
export LESS_TERMCAP_mr=$(tput rev)
export LESS_TERMCAP_mh=$(tput dim)
export LESS_TERMCAP_ZN=$(tput ssubm)
export LESS_TERMCAP_ZV=$(tput rsubm)
export LESS_TERMCAP_ZO=$(tput ssupm)
export LESS_TERMCAP_ZW=$(tput rsupm)
export GROFF_NO_SGR=1

#: Force UTF-8 usage
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8

#: Disable bash deprecation warning on macOS
export BASH_SILENCE_DEPRECATION_WARNING=1

#: User paths
[ -d "$HOME/.local/bin" ] && PATH="$PATH:$HOME/.local/bin"

#: Disable the XON/XOFF feature for forward-search-history (C-s)
stty -ixon

#: Avoid running when pasting from clipboard
bind 'set enable-bracketed-paste'

#: Check the window size after each command and, if necessary, update the
#:  values of LINES and COLUMNS.
shopt -s checkwinsize

#: Autocorrect spelling mistakes when using `cd`
shopt -s cdspell
#: Autocorrect spelling mistakes in directory names
shopt -s dirspell 2>/dev/null

#: Remove previous duplicate lines when append to the history file {{{

#: Setting this is not enough As `HISCONTROL` only works with history list
HISTCONTROL=ignoredups:erasedups

#: Must set this otherwise history file will be wiped if history line > HISTSIZE
shopt -s histappend

#: Read this first: https://unix.stackexchange.com/q/18212

#: The top answer seems inappropiate for my case as I don't need to sync
#: between sessions, just want to remove duplicates lines after exit.

#: Then I read this: https://unix.stackexchange.com/q/18212#comment865941_18443.
#: This seems a good way, but if number of commands in session more than
#: `HISTSIZE`, the `.bash_hisitory` will be wiped with `history -w`.
#: I also don't want pressure my Bash with `HISTSIZE=`.
#: So finally I go with this:
clean-history() {
    dedup-history
    #: Or this:
    # dedup-history-2
    #: Two command is equally fast, the `dedup-history-2` keeps the early lines
    #: These line is for remind only
    # history -n
    # history -w
    # history -c
    # history -r
}
#: I trap above command after setting OMP in this file (as it also has its trap)

#: Also append each line to history file for safe keeping
#: If the last command fails, it won't be added to history file
if [ -z "$PROMPT_COMMAND" ]; then
    PROMPT_COMMAND="status=\$?; \
    HISTFILE=~/.cache/bash/history; \
    [ \$status -eq 0 ] && history -a; \
    unset HISTFILE"
else
    PROMPT_COMMAND="status=\$?; \
    HISTFILE=~/.cache/bash/history; \
    [ \$status -eq 0 ] && history -a; \
    unset HISTFILE; \
    $PROMPT_COMMAND"
fi

#: This page is the `history` manual, better than its man page:
#: https://www.gnu.org/software/bash/manual/html_node/Bash-History-Builtins.html

#: Number of lines to store in the history file, will be truncated if too big
HISTFILESIZE=2000

#: Number of lines to remember in the history list, let not pressure the Bash
HISTSIZE="$(($HISTFILESIZE * 2 / 3))"

#: }}}

#: Patterns to ignore saving to the history file (or also history line, sadly)
#: Ref: https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html
#: Make sure `extglob` is on to use extended pattern matching
shopt -s extglob
HISTIGNORE="${HISIGNORE}\
.( /)*:\
+( )*:\
[bf]g+( ):\
&:\
bash+( )+([^ ])*( ):\
cd+( )+([^ ])*( ):\
clear+( ):\
code+( )+([^ ])*( ):\
exit+( ):\
hash+( )+([^ ])*( ):\
history+( )+([^ ])*( ):\
pwd+( ):\
printf+( )+([^ ])*( ):\
rm+( )+([^ ])*( ):\
remove-history*( )*:\
tree+( )+([^ ])*( ):\
type+( )+([^ ])*( ):\
which+( )+([^ ])*( )"
#: Ignore all aliases with pattern: `alias<spaces><anything-not-space><spaces>`
# HISTIGNORE="${HISTIGNORE}\
# $(alias | sed 's/^alias \([^ =]\+\)=.*/:\1+( )+([^ ])*( )/' | tr -d '\n')"

#: Ignore some filetypes in autocompletion
FIGNORE="${FIGNORE}:\
~:\
.cmd:\
.hidden:\
.log:\
.swp:\
.uuid"

#: The pattern "**" used in a pathname expansion context will match all files
#: and zero or more directories and subdirectories
shopt -s globstar 2>/dev/null

#: Colored GCC warnings and errors
export GCC_COLORS="\
error=01;31:\
warning=01;35:\
note=01;36:\
caret=01;32:\
locus=01:\
quote=01"

#: Colored prompt in case no powerline is used: `user@host:dir`
[ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ] &&
    debian_chroot=$(cat /etc/debian_chroot)
[ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null &&
    PS1="${debian_chroot:+($debian_chroot)}\
\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ "
[[ "$TERM" =~ (xterm.*|rxvt.*) ]] &&
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"

#: Enable programmable completion features
[ -f /etc/bash_completion ] && ! shopt -oq posix && source /etc/bash_completion
[[ -r "$(brew --prefix)/etc/bash_completion" ]] &&
    source "$(brew --prefix)/etc/bash_completion"

#: }}}

#: Tools {{{

#: Opt out .NET telemetry
export DOTNET_CLI_TELEMETRY_OPTOUT=1

#: GitHub CLI completion
eval "$(gh completion -s bash)"

#: Pyenv
# export PYENV_ROOT="$HOME/.pyenv"
# export PATH="$PYENV_ROOT/bin:$PATH"
#: I don't think we need this if it has been run in `.profile`
# eval "$(pyenv init -)"
# eval "$(pyenv virtualenv-init -)"

#: Poetry
export PATH="$PATH:$HOME/.poetry/bin"
export POETRY_VIRTUALENVS_IN_PROJECT=1

#: Rust programing language
include "$HOME/.cargo/env"

#: Oh My Posh
eval "$(oh-my-posh init bash)"

#: Add the `.bash_history` cleanup to the existing trapped signal EXIT
add-trap clean-history EXIT

#: IBus Bamboo
export GTK_IM_MODULE=ibus
export QT_IM_MODULE=ibus
export XMODIFIERS=@im=ibus
#: For Qt4 application
export QT4_IM_MODULE=ibus
#: For Clutter/OpenGL application
export CLUTTER_IM_MODULE=ibus
export GLFW_IM_MODULE=ibus

#: Fzf
include ~/.config/bash/fzf.bash
alias vimf="fzf --bind 'enter:abort+execute(vim -p {+} </dev/tty)'"
#: Or doing this, I don't know which one is better
#: Remember filepaths may contains spaces
# vimf () {
#     readarray -t files < <(fzf -m)
#     nvim -p "${files[@]}"
# }

#: Ripgrep config file
[ -f "$HOME/.config/ripgrep/config" ] && export RIPGREP_CONFIG_PATH="$HOME/.config/ripgrep/config"

# export GPG_TTY=$(tty)

#: Use kitty repo to run code if available
# export KITTY_DEVELOP_FROM=~/Desktop/Projects/kitty
#: Kitty shell integration
if [ -n "$KITTY_INSTALLATION_DIR" ] &&
    [ -f "$KITTY_INSTALLATION_DIR/shell-integration/bash/kitty.bash" ]; then
    source "$KITTY_INSTALLATION_DIR/shell-integration/bash/kitty.bash"
fi

#: }}}
